/* tslint:disable */
/* eslint-disable */
/**
 * MiniAuth API
 * A simple authentication service with user and organization management
 *
 * The version of the OpenAPI document: 1.0
 * Contact: support@swagger.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @enum {string}
 */

export const DatabaseUserRole = {
    UserRoleAdmin: 'admin',
    UserRoleUser: 'user'
} as const;

export type DatabaseUserRole = typeof DatabaseUserRole[keyof typeof DatabaseUserRole];


/**
 * 
 * @export
 * @interface HandlersAdminCreateUserRequest
 */
export interface HandlersAdminCreateUserRequest {
    /**
     * 
     * @type {string}
     * @memberof HandlersAdminCreateUserRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof HandlersAdminCreateUserRequest
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof HandlersAdminCreateUserRequest
     */
    'username': string;
}
/**
 * 
 * @export
 * @interface HandlersAdminListUsersResponse
 */
export interface HandlersAdminListUsersResponse {
    /**
     * 
     * @type {number}
     * @memberof HandlersAdminListUsersResponse
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof HandlersAdminListUsersResponse
     */
    'size'?: number;
    /**
     * 
     * @type {number}
     * @memberof HandlersAdminListUsersResponse
     */
    'total'?: number;
    /**
     * 
     * @type {Array<HandlersAdminUserInfo>}
     * @memberof HandlersAdminListUsersResponse
     */
    'users'?: Array<HandlersAdminUserInfo>;
}
/**
 * 
 * @export
 * @interface HandlersAdminUpdateUserRequest
 */
export interface HandlersAdminUpdateUserRequest {
    /**
     * 
     * @type {string}
     * @memberof HandlersAdminUpdateUserRequest
     */
    'email'?: string;
    /**
     * 
     * @type {DatabaseUserRole}
     * @memberof HandlersAdminUpdateUserRequest
     */
    'role'?: DatabaseUserRole;
    /**
     * 
     * @type {string}
     * @memberof HandlersAdminUpdateUserRequest
     */
    'username'?: string;
}


/**
 * 
 * @export
 * @interface HandlersAdminUpdateUserRoleRequest
 */
export interface HandlersAdminUpdateUserRoleRequest {
    /**
     * 
     * @type {DatabaseUserRole}
     * @memberof HandlersAdminUpdateUserRoleRequest
     */
    'role': DatabaseUserRole;
}


/**
 * 
 * @export
 * @interface HandlersAdminUserInfo
 */
export interface HandlersAdminUserInfo {
    /**
     * 
     * @type {string}
     * @memberof HandlersAdminUserInfo
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof HandlersAdminUserInfo
     */
    'email'?: string;
    /**
     * 
     * @type {number}
     * @memberof HandlersAdminUserInfo
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof HandlersAdminUserInfo
     */
    'org_count'?: number;
    /**
     * 
     * @type {DatabaseUserRole}
     * @memberof HandlersAdminUserInfo
     */
    'role'?: DatabaseUserRole;
    /**
     * 
     * @type {string}
     * @memberof HandlersAdminUserInfo
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof HandlersAdminUserInfo
     */
    'username'?: string;
}


/**
 * 
 * @export
 * @interface HandlersAdminUserResponse
 */
export interface HandlersAdminUserResponse {
    /**
     * 
     * @type {string}
     * @memberof HandlersAdminUserResponse
     */
    'email'?: string;
    /**
     * 
     * @type {number}
     * @memberof HandlersAdminUserResponse
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof HandlersAdminUserResponse
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof HandlersAdminUserResponse
     */
    'username'?: string;
}
/**
 * 
 * @export
 * @interface HandlersChangePasswordRequest
 */
export interface HandlersChangePasswordRequest {
    /**
     * 
     * @type {string}
     * @memberof HandlersChangePasswordRequest
     */
    'currentPassword': string;
    /**
     * 
     * @type {string}
     * @memberof HandlersChangePasswordRequest
     */
    'newPassword': string;
}
/**
 * 
 * @export
 * @interface HandlersCreateUserRequest
 */
export interface HandlersCreateUserRequest {
    /**
     * 
     * @type {string}
     * @memberof HandlersCreateUserRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof HandlersCreateUserRequest
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof HandlersCreateUserRequest
     */
    'username': string;
}
/**
 * 
 * @export
 * @interface HandlersCreateUserResponse
 */
export interface HandlersCreateUserResponse {
    /**
     * 
     * @type {string}
     * @memberof HandlersCreateUserResponse
     */
    'email'?: string;
    /**
     * 
     * @type {number}
     * @memberof HandlersCreateUserResponse
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof HandlersCreateUserResponse
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof HandlersCreateUserResponse
     */
    'username'?: string;
}
/**
 * 
 * @export
 * @interface HandlersGetUserResponse
 */
export interface HandlersGetUserResponse {
    /**
     * 
     * @type {string}
     * @memberof HandlersGetUserResponse
     */
    'email'?: string;
    /**
     * 
     * @type {number}
     * @memberof HandlersGetUserResponse
     */
    'id'?: number;
    /**
     * 
     * @type {Array<HandlersOrganizationInfo>}
     * @memberof HandlersGetUserResponse
     */
    'organizations'?: Array<HandlersOrganizationInfo>;
    /**
     * 
     * @type {DatabaseUserRole}
     * @memberof HandlersGetUserResponse
     */
    'role'?: DatabaseUserRole;
    /**
     * 
     * @type {string}
     * @memberof HandlersGetUserResponse
     */
    'username'?: string;
}


/**
 * 
 * @export
 * @interface HandlersLoginRequest
 */
export interface HandlersLoginRequest {
    /**
     * 
     * @type {string}
     * @memberof HandlersLoginRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof HandlersLoginRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface HandlersLoginResponse
 */
export interface HandlersLoginResponse {
    /**
     * 
     * @type {string}
     * @memberof HandlersLoginResponse
     */
    'email'?: string;
    /**
     * 
     * @type {number}
     * @memberof HandlersLoginResponse
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof HandlersLoginResponse
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof HandlersLoginResponse
     */
    'username'?: string;
}
/**
 * 
 * @export
 * @interface HandlersOrganizationInfo
 */
export interface HandlersOrganizationInfo {
    /**
     * 
     * @type {number}
     * @memberof HandlersOrganizationInfo
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof HandlersOrganizationInfo
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof HandlersOrganizationInfo
     */
    'role'?: string;
    /**
     * 
     * @type {string}
     * @memberof HandlersOrganizationInfo
     */
    'slug'?: string;
}
/**
 * 
 * @export
 * @interface HandlersUpdateProfileRequest
 */
export interface HandlersUpdateProfileRequest {
    /**
     * 
     * @type {string}
     * @memberof HandlersUpdateProfileRequest
     */
    'username': string;
}
/**
 * 
 * @export
 * @interface ServiceApplicationCreateRequest
 */
export interface ServiceApplicationCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof ServiceApplicationCreateRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceApplicationCreateRequest
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ServiceApplicationCreateRequest
     */
    'redirect_uris': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ServiceApplicationCreateRequest
     */
    'scopes'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceApplicationCreateRequest
     */
    'trusted'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ServiceApplicationCreateRequest
     */
    'website'?: string;
}
/**
 * 
 * @export
 * @interface ServiceApplicationResponse
 */
export interface ServiceApplicationResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ServiceApplicationResponse
     */
    'active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ServiceApplicationResponse
     */
    'client_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceApplicationResponse
     */
    'client_secret'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceApplicationResponse
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceApplicationResponse
     */
    'created_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceApplicationResponse
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof ServiceApplicationResponse
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ServiceApplicationResponse
     */
    'name'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ServiceApplicationResponse
     */
    'redirect_uris'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ServiceApplicationResponse
     */
    'scopes'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceApplicationResponse
     */
    'trusted'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ServiceApplicationResponse
     */
    'website'?: string;
}
/**
 * 
 * @export
 * @interface ServiceInternalApplicationCreateRequest
 */
export interface ServiceInternalApplicationCreateRequest {
    /**
     * Custom client ID
     * @type {string}
     * @memberof ServiceInternalApplicationCreateRequest
     */
    'client_id': string;
    /**
     * Custom client secret
     * @type {string}
     * @memberof ServiceInternalApplicationCreateRequest
     */
    'client_secret': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceInternalApplicationCreateRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceInternalApplicationCreateRequest
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ServiceInternalApplicationCreateRequest
     */
    'redirect_uris': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ServiceInternalApplicationCreateRequest
     */
    'scopes'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceInternalApplicationCreateRequest
     */
    'trusted'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ServiceInternalApplicationCreateRequest
     */
    'website'?: string;
}
/**
 * 
 * @export
 * @interface ServiceTokenResponse
 */
export interface ServiceTokenResponse {
    /**
     * 
     * @type {string}
     * @memberof ServiceTokenResponse
     */
    'access_token'?: string;
    /**
     * 
     * @type {number}
     * @memberof ServiceTokenResponse
     */
    'expires_in'?: number;
    /**
     * 
     * @type {string}
     * @memberof ServiceTokenResponse
     */
    'refresh_token'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceTokenResponse
     */
    'scope'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceTokenResponse
     */
    'token_type'?: string;
}

/**
 * AdminApi - axios parameter creator
 * @export
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a paginated list of all users in the system
         * @summary List all users (Admin)
         * @param {number} [page] Page number (default: 1)
         * @param {number} [size] Page size (default: 10)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUsersGet: async (page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently delete a user account and all related data (admin operation)
         * @summary Delete user (Admin)
         * @param {number} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUsersIdDelete: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminUsersIdDelete', 'id', id)
            const localVarPath = `/admin/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get detailed information about a specific user
         * @summary Get user by ID (Admin)
         * @param {number} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUsersIdGet: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminUsersIdGet', 'id', id)
            const localVarPath = `/admin/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update user information (admin operation)
         * @summary Update user (Admin)
         * @param {number} id User ID
         * @param {HandlersAdminUpdateUserRequest} user User update request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUsersIdPut: async (id: number, user: HandlersAdminUpdateUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminUsersIdPut', 'id', id)
            // verify required parameter 'user' is not null or undefined
            assertParamExists('adminUsersIdPut', 'user', user)
            const localVarPath = `/admin/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reset a user\'s password to a new value (admin operation)
         * @summary Reset user password (Admin)
         * @param {number} id User ID
         * @param {{ [key: string]: string; }} password New password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUsersIdResetPasswordPost: async (id: number, password: { [key: string]: string; }, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminUsersIdResetPasswordPost', 'id', id)
            // verify required parameter 'password' is not null or undefined
            assertParamExists('adminUsersIdResetPasswordPost', 'password', password)
            const localVarPath = `/admin/users/{id}/reset-password`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(password, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a user\'s role (admin or user)
         * @summary Update user role (Admin)
         * @param {number} id User ID
         * @param {HandlersAdminUpdateUserRoleRequest} role User role update request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUsersIdRolePut: async (id: number, role: HandlersAdminUpdateUserRoleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminUsersIdRolePut', 'id', id)
            // verify required parameter 'role' is not null or undefined
            assertParamExists('adminUsersIdRolePut', 'role', role)
            const localVarPath = `/admin/users/{id}/role`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(role, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new user account (admin operation)
         * @summary Create user (Admin)
         * @param {HandlersAdminCreateUserRequest} user User creation request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUsersPost: async (user: HandlersAdminCreateUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('adminUsersPost', 'user', user)
            const localVarPath = `/admin/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminApi - functional programming interface
 * @export
 */
export const AdminApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a paginated list of all users in the system
         * @summary List all users (Admin)
         * @param {number} [page] Page number (default: 1)
         * @param {number} [size] Page size (default: 10)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminUsersGet(page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HandlersAdminListUsersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminUsersGet(page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminUsersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permanently delete a user account and all related data (admin operation)
         * @summary Delete user (Admin)
         * @param {number} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminUsersIdDelete(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: string; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminUsersIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminUsersIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get detailed information about a specific user
         * @summary Get user by ID (Admin)
         * @param {number} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminUsersIdGet(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HandlersGetUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminUsersIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminUsersIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update user information (admin operation)
         * @summary Update user (Admin)
         * @param {number} id User ID
         * @param {HandlersAdminUpdateUserRequest} user User update request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminUsersIdPut(id: number, user: HandlersAdminUpdateUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HandlersAdminUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminUsersIdPut(id, user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminUsersIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Reset a user\'s password to a new value (admin operation)
         * @summary Reset user password (Admin)
         * @param {number} id User ID
         * @param {{ [key: string]: string; }} password New password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminUsersIdResetPasswordPost(id: number, password: { [key: string]: string; }, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: string; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminUsersIdResetPasswordPost(id, password, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminUsersIdResetPasswordPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a user\'s role (admin or user)
         * @summary Update user role (Admin)
         * @param {number} id User ID
         * @param {HandlersAdminUpdateUserRoleRequest} role User role update request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminUsersIdRolePut(id: number, role: HandlersAdminUpdateUserRoleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HandlersAdminUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminUsersIdRolePut(id, role, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminUsersIdRolePut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new user account (admin operation)
         * @summary Create user (Admin)
         * @param {HandlersAdminCreateUserRequest} user User creation request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminUsersPost(user: HandlersAdminCreateUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HandlersAdminUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminUsersPost(user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminUsersPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdminApi - factory interface
 * @export
 */
export const AdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminApiFp(configuration)
    return {
        /**
         * Get a paginated list of all users in the system
         * @summary List all users (Admin)
         * @param {number} [page] Page number (default: 1)
         * @param {number} [size] Page size (default: 10)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUsersGet(page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<HandlersAdminListUsersResponse> {
            return localVarFp.adminUsersGet(page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Permanently delete a user account and all related data (admin operation)
         * @summary Delete user (Admin)
         * @param {number} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUsersIdDelete(id: number, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: string; }> {
            return localVarFp.adminUsersIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get detailed information about a specific user
         * @summary Get user by ID (Admin)
         * @param {number} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUsersIdGet(id: number, options?: RawAxiosRequestConfig): AxiosPromise<HandlersGetUserResponse> {
            return localVarFp.adminUsersIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update user information (admin operation)
         * @summary Update user (Admin)
         * @param {number} id User ID
         * @param {HandlersAdminUpdateUserRequest} user User update request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUsersIdPut(id: number, user: HandlersAdminUpdateUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<HandlersAdminUserResponse> {
            return localVarFp.adminUsersIdPut(id, user, options).then((request) => request(axios, basePath));
        },
        /**
         * Reset a user\'s password to a new value (admin operation)
         * @summary Reset user password (Admin)
         * @param {number} id User ID
         * @param {{ [key: string]: string; }} password New password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUsersIdResetPasswordPost(id: number, password: { [key: string]: string; }, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: string; }> {
            return localVarFp.adminUsersIdResetPasswordPost(id, password, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a user\'s role (admin or user)
         * @summary Update user role (Admin)
         * @param {number} id User ID
         * @param {HandlersAdminUpdateUserRoleRequest} role User role update request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUsersIdRolePut(id: number, role: HandlersAdminUpdateUserRoleRequest, options?: RawAxiosRequestConfig): AxiosPromise<HandlersAdminUserResponse> {
            return localVarFp.adminUsersIdRolePut(id, role, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new user account (admin operation)
         * @summary Create user (Admin)
         * @param {HandlersAdminCreateUserRequest} user User creation request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUsersPost(user: HandlersAdminCreateUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<HandlersAdminUserResponse> {
            return localVarFp.adminUsersPost(user, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminApi - object-oriented interface
 * @export
 * @class AdminApi
 * @extends {BaseAPI}
 */
export class AdminApi extends BaseAPI {
    /**
     * Get a paginated list of all users in the system
     * @summary List all users (Admin)
     * @param {number} [page] Page number (default: 1)
     * @param {number} [size] Page size (default: 10)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminUsersGet(page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminUsersGet(page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permanently delete a user account and all related data (admin operation)
     * @summary Delete user (Admin)
     * @param {number} id User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminUsersIdDelete(id: number, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminUsersIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get detailed information about a specific user
     * @summary Get user by ID (Admin)
     * @param {number} id User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminUsersIdGet(id: number, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminUsersIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update user information (admin operation)
     * @summary Update user (Admin)
     * @param {number} id User ID
     * @param {HandlersAdminUpdateUserRequest} user User update request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminUsersIdPut(id: number, user: HandlersAdminUpdateUserRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminUsersIdPut(id, user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reset a user\'s password to a new value (admin operation)
     * @summary Reset user password (Admin)
     * @param {number} id User ID
     * @param {{ [key: string]: string; }} password New password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminUsersIdResetPasswordPost(id: number, password: { [key: string]: string; }, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminUsersIdResetPasswordPost(id, password, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a user\'s role (admin or user)
     * @summary Update user role (Admin)
     * @param {number} id User ID
     * @param {HandlersAdminUpdateUserRoleRequest} role User role update request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminUsersIdRolePut(id: number, role: HandlersAdminUpdateUserRoleRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminUsersIdRolePut(id, role, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new user account (admin operation)
     * @summary Create user (Admin)
     * @param {HandlersAdminCreateUserRequest} user User creation request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminUsersPost(user: HandlersAdminCreateUserRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminUsersPost(user, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Authenticate user with email and password and create a session
         * @summary User login
         * @param {HandlersLoginRequest} credentials Login credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginPost: async (credentials: HandlersLoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'credentials' is not null or undefined
            assertParamExists('loginPost', 'credentials', credentials)
            const localVarPath = `/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(credentials, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Log out the current user and destroy the session
         * @summary User logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change the current user\'s password
         * @summary Change user password
         * @param {HandlersChangePasswordRequest} request Change password request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meChangePasswordPut: async (request: HandlersChangePasswordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('meChangePasswordPut', 'request', request)
            const localVarPath = `/me/change-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the currently authenticated user\'s information from session
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the current user\'s profile information
         * @summary Update user profile
         * @param {HandlersUpdateProfileRequest} request Update profile request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meProfilePut: async (request: HandlersUpdateProfileRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('meProfilePut', 'request', request)
            const localVarPath = `/me/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Authenticate user with email and password and create a session
         * @summary User login
         * @param {HandlersLoginRequest} credentials Login credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginPost(credentials: HandlersLoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HandlersLoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginPost(credentials, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.loginPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Log out the current user and destroy the session
         * @summary User logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logoutPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: string; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logoutPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.logoutPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change the current user\'s password
         * @summary Change user password
         * @param {HandlersChangePasswordRequest} request Change password request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async meChangePasswordPut(request: HandlersChangePasswordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: string; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.meChangePasswordPut(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.meChangePasswordPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the currently authenticated user\'s information from session
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async meGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HandlersGetUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.meGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.meGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the current user\'s profile information
         * @summary Update user profile
         * @param {HandlersUpdateProfileRequest} request Update profile request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async meProfilePut(request: HandlersUpdateProfileRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HandlersGetUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.meProfilePut(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.meProfilePut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Authenticate user with email and password and create a session
         * @summary User login
         * @param {HandlersLoginRequest} credentials Login credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginPost(credentials: HandlersLoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<HandlersLoginResponse> {
            return localVarFp.loginPost(credentials, options).then((request) => request(axios, basePath));
        },
        /**
         * Log out the current user and destroy the session
         * @summary User logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutPost(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: string; }> {
            return localVarFp.logoutPost(options).then((request) => request(axios, basePath));
        },
        /**
         * Change the current user\'s password
         * @summary Change user password
         * @param {HandlersChangePasswordRequest} request Change password request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meChangePasswordPut(request: HandlersChangePasswordRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: string; }> {
            return localVarFp.meChangePasswordPut(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the currently authenticated user\'s information from session
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meGet(options?: RawAxiosRequestConfig): AxiosPromise<HandlersGetUserResponse> {
            return localVarFp.meGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Update the current user\'s profile information
         * @summary Update user profile
         * @param {HandlersUpdateProfileRequest} request Update profile request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meProfilePut(request: HandlersUpdateProfileRequest, options?: RawAxiosRequestConfig): AxiosPromise<HandlersGetUserResponse> {
            return localVarFp.meProfilePut(request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * Authenticate user with email and password and create a session
     * @summary User login
     * @param {HandlersLoginRequest} credentials Login credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public loginPost(credentials: HandlersLoginRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).loginPost(credentials, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Log out the current user and destroy the session
     * @summary User logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public logoutPost(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).logoutPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change the current user\'s password
     * @summary Change user password
     * @param {HandlersChangePasswordRequest} request Change password request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public meChangePasswordPut(request: HandlersChangePasswordRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).meChangePasswordPut(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the currently authenticated user\'s information from session
     * @summary Get current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public meGet(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).meGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the current user\'s profile information
     * @summary Update user profile
     * @param {HandlersUpdateProfileRequest} request Update profile request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public meProfilePut(request: HandlersUpdateProfileRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).meProfilePut(request, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OAuthApi - axios parameter creator
 * @export
 */
export const OAuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all OAuth applications (admin only)
         * @summary List OAuth Applications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminOauthApplicationsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/oauth/applications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an OAuth application (admin only)
         * @summary Delete OAuth Application
         * @param {number} id Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminOauthApplicationsIdDelete: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminOauthApplicationsIdDelete', 'id', id)
            const localVarPath = `/admin/oauth/applications/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an OAuth application (admin only)
         * @summary Update OAuth Application
         * @param {number} id Application ID
         * @param {ServiceApplicationCreateRequest} request Application data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminOauthApplicationsIdPut: async (id: number, request: ServiceApplicationCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminOauthApplicationsIdPut', 'id', id)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('adminOauthApplicationsIdPut', 'request', request)
            const localVarPath = `/admin/oauth/applications/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Activate or deactivate an OAuth application (admin only)
         * @summary Toggle OAuth Application Status
         * @param {number} id Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminOauthApplicationsIdTogglePost: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminOauthApplicationsIdTogglePost', 'id', id)
            const localVarPath = `/admin/oauth/applications/{id}/toggle`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Toggle the trusted status of an OAuth application (admin only)
         * @summary Toggle OAuth Application Trusted Status
         * @param {number} id Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminOauthApplicationsIdToggleTrustedPost: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminOauthApplicationsIdToggleTrustedPost', 'id', id)
            const localVarPath = `/admin/oauth/applications/{id}/toggle-trusted`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new OAuth application (admin only)
         * @summary Create OAuth Application
         * @param {ServiceApplicationCreateRequest} request Application data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminOauthApplicationsPost: async (request: ServiceApplicationCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('adminOauthApplicationsPost', 'request', request)
            const localVarPath = `/admin/oauth/applications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create multiple OAuth applications with custom client_id and secret (internal API, requires internal token or admin session)
         * @summary Batch Internal Create OAuth Applications
         * @param {Array<ServiceInternalApplicationCreateRequest>} request Array of application data with custom credentials
         * @param {string} [authorization] Internal token (Bearer &lt;token&gt; or Internal &lt;token&gt;)
         * @param {string} [xInternalToken] Internal token
         * @param {string} [internalToken] Internal token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminOauthInternalApplicationsBatchPost: async (request: Array<ServiceInternalApplicationCreateRequest>, authorization?: string, xInternalToken?: string, internalToken?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('adminOauthInternalApplicationsBatchPost', 'request', request)
            const localVarPath = `/admin/oauth/internal/applications/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (internalToken !== undefined) {
                localVarQueryParameter['internal_token'] = internalToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            if (xInternalToken != null) {
                localVarHeaderParameter['X-Internal-Token'] = String(xInternalToken);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an OAuth application with custom client_id and secret (internal API, requires internal token or admin session)
         * @summary Internal Create OAuth Application
         * @param {ServiceInternalApplicationCreateRequest} request Application data with custom credentials
         * @param {string} [authorization] Internal token (Bearer &lt;token&gt; or Internal &lt;token&gt;)
         * @param {string} [xInternalToken] Internal token
         * @param {string} [internalToken] Internal token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminOauthInternalApplicationsPost: async (request: ServiceInternalApplicationCreateRequest, authorization?: string, xInternalToken?: string, internalToken?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('adminOauthInternalApplicationsPost', 'request', request)
            const localVarPath = `/admin/oauth/internal/applications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (internalToken !== undefined) {
                localVarQueryParameter['internal_token'] = internalToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            if (xInternalToken != null) {
                localVarHeaderParameter['X-Internal-Token'] = String(xInternalToken);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start OAuth authorization flow
         * @summary OAuth Authorization
         * @param {string} responseType Response type (must be \&#39;code\&#39;)
         * @param {string} clientId OAuth client ID
         * @param {string} redirectUri Redirect URI
         * @param {string} [scope] Requested scopes (space-separated)
         * @param {string} [state] State parameter for CSRF protection
         * @param {string} [codeChallenge] PKCE code challenge
         * @param {string} [codeChallengeMethod] PKCE code challenge method
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthAuthorizeGet: async (responseType: string, clientId: string, redirectUri: string, scope?: string, state?: string, codeChallenge?: string, codeChallengeMethod?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'responseType' is not null or undefined
            assertParamExists('oauthAuthorizeGet', 'responseType', responseType)
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('oauthAuthorizeGet', 'clientId', clientId)
            // verify required parameter 'redirectUri' is not null or undefined
            assertParamExists('oauthAuthorizeGet', 'redirectUri', redirectUri)
            const localVarPath = `/oauth/authorize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (responseType !== undefined) {
                localVarQueryParameter['response_type'] = responseType;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['client_id'] = clientId;
            }

            if (redirectUri !== undefined) {
                localVarQueryParameter['redirect_uri'] = redirectUri;
            }

            if (scope !== undefined) {
                localVarQueryParameter['scope'] = scope;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (codeChallenge !== undefined) {
                localVarQueryParameter['code_challenge'] = codeChallenge;
            }

            if (codeChallengeMethod !== undefined) {
                localVarQueryParameter['code_challenge_method'] = codeChallengeMethod;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Handle user\'s authorization decision
         * @summary OAuth Authorization Decision
         * @param {{ [key: string]: any; }} request Authorization decision
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthAuthorizePost: async (request: { [key: string]: any; }, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('oauthAuthorizePost', 'request', request)
            const localVarPath = `/oauth/authorize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Exchange authorization code or refresh token for access token
         * @summary OAuth Token
         * @param {string} grantType Grant type (authorization_code or refresh_token)
         * @param {string} clientId OAuth client ID
         * @param {string} [code] Authorization code (required for authorization_code grant)
         * @param {string} [redirectUri] Redirect URI (required for authorization_code grant)
         * @param {string} [clientSecret] OAuth client secret
         * @param {string} [codeVerifier] PKCE code verifier
         * @param {string} [refreshToken] Refresh token (required for refresh_token grant)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthTokenPost: async (grantType: string, clientId: string, code?: string, redirectUri?: string, clientSecret?: string, codeVerifier?: string, refreshToken?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'grantType' is not null or undefined
            assertParamExists('oauthTokenPost', 'grantType', grantType)
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('oauthTokenPost', 'clientId', clientId)
            const localVarPath = `/oauth/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (grantType !== undefined) { 
                localVarFormParams.set('grant_type', grantType as any);
            }
    
            if (code !== undefined) { 
                localVarFormParams.set('code', code as any);
            }
    
            if (redirectUri !== undefined) { 
                localVarFormParams.set('redirect_uri', redirectUri as any);
            }
    
            if (clientId !== undefined) { 
                localVarFormParams.set('client_id', clientId as any);
            }
    
            if (clientSecret !== undefined) { 
                localVarFormParams.set('client_secret', clientSecret as any);
            }
    
            if (codeVerifier !== undefined) { 
                localVarFormParams.set('code_verifier', codeVerifier as any);
            }
    
            if (refreshToken !== undefined) { 
                localVarFormParams.set('refresh_token', refreshToken as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user information using access token
         * @summary OAuth User Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthUserinfoGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/oauth/userinfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OAuthApi - functional programming interface
 * @export
 */
export const OAuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OAuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all OAuth applications (admin only)
         * @summary List OAuth Applications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminOauthApplicationsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ServiceApplicationResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminOauthApplicationsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OAuthApi.adminOauthApplicationsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an OAuth application (admin only)
         * @summary Delete OAuth Application
         * @param {number} id Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminOauthApplicationsIdDelete(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminOauthApplicationsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OAuthApi.adminOauthApplicationsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an OAuth application (admin only)
         * @summary Update OAuth Application
         * @param {number} id Application ID
         * @param {ServiceApplicationCreateRequest} request Application data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminOauthApplicationsIdPut(id: number, request: ServiceApplicationCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceApplicationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminOauthApplicationsIdPut(id, request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OAuthApi.adminOauthApplicationsIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Activate or deactivate an OAuth application (admin only)
         * @summary Toggle OAuth Application Status
         * @param {number} id Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminOauthApplicationsIdTogglePost(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminOauthApplicationsIdTogglePost(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OAuthApi.adminOauthApplicationsIdTogglePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Toggle the trusted status of an OAuth application (admin only)
         * @summary Toggle OAuth Application Trusted Status
         * @param {number} id Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminOauthApplicationsIdToggleTrustedPost(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminOauthApplicationsIdToggleTrustedPost(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OAuthApi.adminOauthApplicationsIdToggleTrustedPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new OAuth application (admin only)
         * @summary Create OAuth Application
         * @param {ServiceApplicationCreateRequest} request Application data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminOauthApplicationsPost(request: ServiceApplicationCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceApplicationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminOauthApplicationsPost(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OAuthApi.adminOauthApplicationsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create multiple OAuth applications with custom client_id and secret (internal API, requires internal token or admin session)
         * @summary Batch Internal Create OAuth Applications
         * @param {Array<ServiceInternalApplicationCreateRequest>} request Array of application data with custom credentials
         * @param {string} [authorization] Internal token (Bearer &lt;token&gt; or Internal &lt;token&gt;)
         * @param {string} [xInternalToken] Internal token
         * @param {string} [internalToken] Internal token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminOauthInternalApplicationsBatchPost(request: Array<ServiceInternalApplicationCreateRequest>, authorization?: string, xInternalToken?: string, internalToken?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminOauthInternalApplicationsBatchPost(request, authorization, xInternalToken, internalToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OAuthApi.adminOauthInternalApplicationsBatchPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create an OAuth application with custom client_id and secret (internal API, requires internal token or admin session)
         * @summary Internal Create OAuth Application
         * @param {ServiceInternalApplicationCreateRequest} request Application data with custom credentials
         * @param {string} [authorization] Internal token (Bearer &lt;token&gt; or Internal &lt;token&gt;)
         * @param {string} [xInternalToken] Internal token
         * @param {string} [internalToken] Internal token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminOauthInternalApplicationsPost(request: ServiceInternalApplicationCreateRequest, authorization?: string, xInternalToken?: string, internalToken?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceApplicationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminOauthInternalApplicationsPost(request, authorization, xInternalToken, internalToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OAuthApi.adminOauthInternalApplicationsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Start OAuth authorization flow
         * @summary OAuth Authorization
         * @param {string} responseType Response type (must be \&#39;code\&#39;)
         * @param {string} clientId OAuth client ID
         * @param {string} redirectUri Redirect URI
         * @param {string} [scope] Requested scopes (space-separated)
         * @param {string} [state] State parameter for CSRF protection
         * @param {string} [codeChallenge] PKCE code challenge
         * @param {string} [codeChallengeMethod] PKCE code challenge method
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oauthAuthorizeGet(responseType: string, clientId: string, redirectUri: string, scope?: string, state?: string, codeChallenge?: string, codeChallengeMethod?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oauthAuthorizeGet(responseType, clientId, redirectUri, scope, state, codeChallenge, codeChallengeMethod, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OAuthApi.oauthAuthorizeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Handle user\'s authorization decision
         * @summary OAuth Authorization Decision
         * @param {{ [key: string]: any; }} request Authorization decision
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oauthAuthorizePost(request: { [key: string]: any; }, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: string; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oauthAuthorizePost(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OAuthApi.oauthAuthorizePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Exchange authorization code or refresh token for access token
         * @summary OAuth Token
         * @param {string} grantType Grant type (authorization_code or refresh_token)
         * @param {string} clientId OAuth client ID
         * @param {string} [code] Authorization code (required for authorization_code grant)
         * @param {string} [redirectUri] Redirect URI (required for authorization_code grant)
         * @param {string} [clientSecret] OAuth client secret
         * @param {string} [codeVerifier] PKCE code verifier
         * @param {string} [refreshToken] Refresh token (required for refresh_token grant)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oauthTokenPost(grantType: string, clientId: string, code?: string, redirectUri?: string, clientSecret?: string, codeVerifier?: string, refreshToken?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oauthTokenPost(grantType, clientId, code, redirectUri, clientSecret, codeVerifier, refreshToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OAuthApi.oauthTokenPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get user information using access token
         * @summary OAuth User Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oauthUserinfoGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oauthUserinfoGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OAuthApi.oauthUserinfoGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OAuthApi - factory interface
 * @export
 */
export const OAuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OAuthApiFp(configuration)
    return {
        /**
         * Get all OAuth applications (admin only)
         * @summary List OAuth Applications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminOauthApplicationsGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<ServiceApplicationResponse>> {
            return localVarFp.adminOauthApplicationsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an OAuth application (admin only)
         * @summary Delete OAuth Application
         * @param {number} id Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminOauthApplicationsIdDelete(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.adminOauthApplicationsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an OAuth application (admin only)
         * @summary Update OAuth Application
         * @param {number} id Application ID
         * @param {ServiceApplicationCreateRequest} request Application data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminOauthApplicationsIdPut(id: number, request: ServiceApplicationCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ServiceApplicationResponse> {
            return localVarFp.adminOauthApplicationsIdPut(id, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Activate or deactivate an OAuth application (admin only)
         * @summary Toggle OAuth Application Status
         * @param {number} id Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminOauthApplicationsIdTogglePost(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.adminOauthApplicationsIdTogglePost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Toggle the trusted status of an OAuth application (admin only)
         * @summary Toggle OAuth Application Trusted Status
         * @param {number} id Application ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminOauthApplicationsIdToggleTrustedPost(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.adminOauthApplicationsIdToggleTrustedPost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new OAuth application (admin only)
         * @summary Create OAuth Application
         * @param {ServiceApplicationCreateRequest} request Application data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminOauthApplicationsPost(request: ServiceApplicationCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ServiceApplicationResponse> {
            return localVarFp.adminOauthApplicationsPost(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Create multiple OAuth applications with custom client_id and secret (internal API, requires internal token or admin session)
         * @summary Batch Internal Create OAuth Applications
         * @param {Array<ServiceInternalApplicationCreateRequest>} request Array of application data with custom credentials
         * @param {string} [authorization] Internal token (Bearer &lt;token&gt; or Internal &lt;token&gt;)
         * @param {string} [xInternalToken] Internal token
         * @param {string} [internalToken] Internal token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminOauthInternalApplicationsBatchPost(request: Array<ServiceInternalApplicationCreateRequest>, authorization?: string, xInternalToken?: string, internalToken?: string, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.adminOauthInternalApplicationsBatchPost(request, authorization, xInternalToken, internalToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an OAuth application with custom client_id and secret (internal API, requires internal token or admin session)
         * @summary Internal Create OAuth Application
         * @param {ServiceInternalApplicationCreateRequest} request Application data with custom credentials
         * @param {string} [authorization] Internal token (Bearer &lt;token&gt; or Internal &lt;token&gt;)
         * @param {string} [xInternalToken] Internal token
         * @param {string} [internalToken] Internal token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminOauthInternalApplicationsPost(request: ServiceInternalApplicationCreateRequest, authorization?: string, xInternalToken?: string, internalToken?: string, options?: RawAxiosRequestConfig): AxiosPromise<ServiceApplicationResponse> {
            return localVarFp.adminOauthInternalApplicationsPost(request, authorization, xInternalToken, internalToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Start OAuth authorization flow
         * @summary OAuth Authorization
         * @param {string} responseType Response type (must be \&#39;code\&#39;)
         * @param {string} clientId OAuth client ID
         * @param {string} redirectUri Redirect URI
         * @param {string} [scope] Requested scopes (space-separated)
         * @param {string} [state] State parameter for CSRF protection
         * @param {string} [codeChallenge] PKCE code challenge
         * @param {string} [codeChallengeMethod] PKCE code challenge method
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthAuthorizeGet(responseType: string, clientId: string, redirectUri: string, scope?: string, state?: string, codeChallenge?: string, codeChallengeMethod?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.oauthAuthorizeGet(responseType, clientId, redirectUri, scope, state, codeChallenge, codeChallengeMethod, options).then((request) => request(axios, basePath));
        },
        /**
         * Handle user\'s authorization decision
         * @summary OAuth Authorization Decision
         * @param {{ [key: string]: any; }} request Authorization decision
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthAuthorizePost(request: { [key: string]: any; }, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: string; }> {
            return localVarFp.oauthAuthorizePost(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Exchange authorization code or refresh token for access token
         * @summary OAuth Token
         * @param {string} grantType Grant type (authorization_code or refresh_token)
         * @param {string} clientId OAuth client ID
         * @param {string} [code] Authorization code (required for authorization_code grant)
         * @param {string} [redirectUri] Redirect URI (required for authorization_code grant)
         * @param {string} [clientSecret] OAuth client secret
         * @param {string} [codeVerifier] PKCE code verifier
         * @param {string} [refreshToken] Refresh token (required for refresh_token grant)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthTokenPost(grantType: string, clientId: string, code?: string, redirectUri?: string, clientSecret?: string, codeVerifier?: string, refreshToken?: string, options?: RawAxiosRequestConfig): AxiosPromise<ServiceTokenResponse> {
            return localVarFp.oauthTokenPost(grantType, clientId, code, redirectUri, clientSecret, codeVerifier, refreshToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Get user information using access token
         * @summary OAuth User Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthUserinfoGet(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.oauthUserinfoGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OAuthApi - object-oriented interface
 * @export
 * @class OAuthApi
 * @extends {BaseAPI}
 */
export class OAuthApi extends BaseAPI {
    /**
     * Get all OAuth applications (admin only)
     * @summary List OAuth Applications
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public adminOauthApplicationsGet(options?: RawAxiosRequestConfig) {
        return OAuthApiFp(this.configuration).adminOauthApplicationsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an OAuth application (admin only)
     * @summary Delete OAuth Application
     * @param {number} id Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public adminOauthApplicationsIdDelete(id: number, options?: RawAxiosRequestConfig) {
        return OAuthApiFp(this.configuration).adminOauthApplicationsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an OAuth application (admin only)
     * @summary Update OAuth Application
     * @param {number} id Application ID
     * @param {ServiceApplicationCreateRequest} request Application data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public adminOauthApplicationsIdPut(id: number, request: ServiceApplicationCreateRequest, options?: RawAxiosRequestConfig) {
        return OAuthApiFp(this.configuration).adminOauthApplicationsIdPut(id, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Activate or deactivate an OAuth application (admin only)
     * @summary Toggle OAuth Application Status
     * @param {number} id Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public adminOauthApplicationsIdTogglePost(id: number, options?: RawAxiosRequestConfig) {
        return OAuthApiFp(this.configuration).adminOauthApplicationsIdTogglePost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Toggle the trusted status of an OAuth application (admin only)
     * @summary Toggle OAuth Application Trusted Status
     * @param {number} id Application ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public adminOauthApplicationsIdToggleTrustedPost(id: number, options?: RawAxiosRequestConfig) {
        return OAuthApiFp(this.configuration).adminOauthApplicationsIdToggleTrustedPost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new OAuth application (admin only)
     * @summary Create OAuth Application
     * @param {ServiceApplicationCreateRequest} request Application data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public adminOauthApplicationsPost(request: ServiceApplicationCreateRequest, options?: RawAxiosRequestConfig) {
        return OAuthApiFp(this.configuration).adminOauthApplicationsPost(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create multiple OAuth applications with custom client_id and secret (internal API, requires internal token or admin session)
     * @summary Batch Internal Create OAuth Applications
     * @param {Array<ServiceInternalApplicationCreateRequest>} request Array of application data with custom credentials
     * @param {string} [authorization] Internal token (Bearer &lt;token&gt; or Internal &lt;token&gt;)
     * @param {string} [xInternalToken] Internal token
     * @param {string} [internalToken] Internal token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public adminOauthInternalApplicationsBatchPost(request: Array<ServiceInternalApplicationCreateRequest>, authorization?: string, xInternalToken?: string, internalToken?: string, options?: RawAxiosRequestConfig) {
        return OAuthApiFp(this.configuration).adminOauthInternalApplicationsBatchPost(request, authorization, xInternalToken, internalToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an OAuth application with custom client_id and secret (internal API, requires internal token or admin session)
     * @summary Internal Create OAuth Application
     * @param {ServiceInternalApplicationCreateRequest} request Application data with custom credentials
     * @param {string} [authorization] Internal token (Bearer &lt;token&gt; or Internal &lt;token&gt;)
     * @param {string} [xInternalToken] Internal token
     * @param {string} [internalToken] Internal token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public adminOauthInternalApplicationsPost(request: ServiceInternalApplicationCreateRequest, authorization?: string, xInternalToken?: string, internalToken?: string, options?: RawAxiosRequestConfig) {
        return OAuthApiFp(this.configuration).adminOauthInternalApplicationsPost(request, authorization, xInternalToken, internalToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Start OAuth authorization flow
     * @summary OAuth Authorization
     * @param {string} responseType Response type (must be \&#39;code\&#39;)
     * @param {string} clientId OAuth client ID
     * @param {string} redirectUri Redirect URI
     * @param {string} [scope] Requested scopes (space-separated)
     * @param {string} [state] State parameter for CSRF protection
     * @param {string} [codeChallenge] PKCE code challenge
     * @param {string} [codeChallengeMethod] PKCE code challenge method
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public oauthAuthorizeGet(responseType: string, clientId: string, redirectUri: string, scope?: string, state?: string, codeChallenge?: string, codeChallengeMethod?: string, options?: RawAxiosRequestConfig) {
        return OAuthApiFp(this.configuration).oauthAuthorizeGet(responseType, clientId, redirectUri, scope, state, codeChallenge, codeChallengeMethod, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Handle user\'s authorization decision
     * @summary OAuth Authorization Decision
     * @param {{ [key: string]: any; }} request Authorization decision
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public oauthAuthorizePost(request: { [key: string]: any; }, options?: RawAxiosRequestConfig) {
        return OAuthApiFp(this.configuration).oauthAuthorizePost(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Exchange authorization code or refresh token for access token
     * @summary OAuth Token
     * @param {string} grantType Grant type (authorization_code or refresh_token)
     * @param {string} clientId OAuth client ID
     * @param {string} [code] Authorization code (required for authorization_code grant)
     * @param {string} [redirectUri] Redirect URI (required for authorization_code grant)
     * @param {string} [clientSecret] OAuth client secret
     * @param {string} [codeVerifier] PKCE code verifier
     * @param {string} [refreshToken] Refresh token (required for refresh_token grant)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public oauthTokenPost(grantType: string, clientId: string, code?: string, redirectUri?: string, clientSecret?: string, codeVerifier?: string, refreshToken?: string, options?: RawAxiosRequestConfig) {
        return OAuthApiFp(this.configuration).oauthTokenPost(grantType, clientId, code, redirectUri, clientSecret, codeVerifier, refreshToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user information using access token
     * @summary OAuth User Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuthApi
     */
    public oauthUserinfoGet(options?: RawAxiosRequestConfig) {
        return OAuthApiFp(this.configuration).oauthUserinfoGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get user information including associated organizations and roles
         * @summary Get user by ID
         * @param {number} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdGet: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersIdGet', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new user account with username, email, and password. Also creates a same-name organization with the user as owner.
         * @summary Create a new user
         * @param {HandlersCreateUserRequest} user User creation request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPost: async (user: HandlersCreateUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('usersPost', 'user', user)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Get user information including associated organizations and roles
         * @summary Get user by ID
         * @param {number} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersIdGet(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HandlersGetUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new user account with username, email, and password. Also creates a same-name organization with the user as owner.
         * @summary Create a new user
         * @param {HandlersCreateUserRequest} user User creation request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPost(user: HandlersCreateUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HandlersCreateUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPost(user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Get user information including associated organizations and roles
         * @summary Get user by ID
         * @param {number} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdGet(id: number, options?: RawAxiosRequestConfig): AxiosPromise<HandlersGetUserResponse> {
            return localVarFp.usersIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new user account with username, email, and password. Also creates a same-name organization with the user as owner.
         * @summary Create a new user
         * @param {HandlersCreateUserRequest} user User creation request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPost(user: HandlersCreateUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<HandlersCreateUserResponse> {
            return localVarFp.usersPost(user, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Get user information including associated organizations and roles
     * @summary Get user by ID
     * @param {number} id User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersIdGet(id: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new user account with username, email, and password. Also creates a same-name organization with the user as owner.
     * @summary Create a new user
     * @param {HandlersCreateUserRequest} user User creation request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersPost(user: HandlersCreateUserRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersPost(user, options).then((request) => request(this.axios, this.basePath));
    }
}



